# 斐波拉契数列

```js
function fibonacci(n) {
  const fn = [0, 1];
  if(n <= 1) {
    return fn[n];
    }
    for (let i = 2; i <= n; i++) {
        fn[i] = fn[i - 1] + fn[i - 2];
    }
    return fn[n];
}
```

## 防抖节流
函数防抖 方法是一个函数，它的执行被延迟了 t 毫秒，如果在这个时间窗口内再次调用它，它的执行将被取消。你编写的防抖函数也应该接收传递的参数。

防抖-输入框-回城
节流-滚动加载-普通技能

## 快速排序

```js
function quickSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    const pivot = arr[0]; // 选择第一个元素作为基准值
    const left = [];
    const right = [];

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] < pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }

    // 递归排序左右子数组，然后与基准值合并
    return quickSort(left).concat([pivot], quickSort(right));
}

console.time('quickSort');
console.log(quickSort([3, 6, 8, 10, 1, 2, 1])); // [1, 1, 2, 3, 6, 8, 10]
console.timeEnd('quickSort');

```


## defer 和 async 的区别
无: HTML暂停解析，下载JS文件，执行JS文件，继续解析HTML 

defer: HTML继续解析，并行下载JS，HTML解析完毕后，执行JS文件

async: HTML继续解析，并行下载下载JS文件，下载完毕后暂停解析，执行JS文件

## preLoad 和 preFetch

preLoad: 资源在当前页面使用，优先加载资源

 preFetch: 资源在未来页面使用，浏览器空闲时加载资源


## 事件循环

## 如何理解JS的异步
JS是一门单线程语言，**这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个**。渲染主线程承担着诸多的工作，渲染页面、执行JS代码、处理用户交互等等。
如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白空耗资源，另一方面也会导致页面无法及时响应用户的操作，用户体验会大打折扣。
所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将**事先传递的回调函数包装成任务**，放入消息队列排队，等待主线程调度执行。
在这种异步模式下，浏览器的主线程不会被阻塞，从而保证了页面的流畅性和用户体验。


## JS任务优先级
任务没有优先级，在消息队列中，先进先出
但消息队列是有优先级的
根据W3C的最新解释
每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同队列中取出任务执行。
浏览器必须准备一个微队列，微队列中的任务优先于所有其他任务执行

在目前chrome浏览器中，至少包含下面的队列：
微队列：Promise、MutationObserver，用于存放异步任务，优先级【最高】
交互队列：用户交互事件，用于存放用户交互任务，优先级【高】
延时队列：setTimeout、setInterval，用于存放定时任务，优先级【最低】


## 阐述一下JS的事件循环机制
事件循环又叫做消息循环，是浏览器渲染主线程的工作方式
在Chrome的源码中，它开启一个不会结束的for循环，每次循环从消息队列中取出一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。
过去把消息队列简单分为宏队列和微队列，但是在最新的HTML标准中，消息队列被分为了多个队列，每个队列有自己的优先级，浏览器可以根据实际情况从不同队列中取出任务执行。 
根据W3C的最新解释，每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同队列中取出任务执行。但浏览器必须准备一个微队列，微任务队列的任务具有最高的优先级，必须优先调度执行。

## JS单线程和异步的关系
单线程是异步产生的原因

## 浏览器是如何渲染页面的
当浏览器的网络线程收到html文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程

整个渲染流程分为多个阶段，分别是：html解析、css解析、布局、分层、绘制、分块、合成、显示。每个阶段都有明确的输入输出，上一个阶段的输出是下一个阶段的输入，这样就形成了一个流水线式的渲染流程。

渲染的第一步是解析HTML。

解析过程中遇到css解析css，遇到js执行js。为了提高解析效率，浏览器在开始解析前，会启动一个预解析线程，率先下载html文档中的css和js文件，这样在解析到css和js时，就可以直接使用预解析线程下载好的文件，而不用等待网络线程下载。

如果主线程解析到link位置，此时外部的css文件还没下载解析好，主线程不会等待，继续解析后续的HTML。这是因为下载和解析css的工作是由预解析线程完成的。这就是Css不会阻塞HTML解析的原因。

如果主线程解析到script位置，此时外部的js文件还没下载解析好，主线程会停下来，等待js文件下载解析完成，再继续解析后续的HTML。这是因为js代码的执行可能会改变DOM结构，所以DOM树的生成必须暂停，这就是JS会阻塞HTML解析的原因。

第一步完成后，会得到DOM树和CSSOM树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在CSSOM树中。


## 输入url浏览器发生了什么
解析URL：浏览器解析URL以确定要访问的协议（如HTTP或HTTPS）、服务器的域名和路径。

DNS查询：浏览器需要将域名转换为IP地址，这通常涉及到查询DNS服务器。

建立连接：浏览器与服务器的IP地址上的端口建立TCP连接（如果是HTTPS，则还需要建立TLS连接以确保加密）。

发送HTTP请求：浏览器构建HTTP请求（对于HTTPS，请求在发送前会被加密），并通过建立的连接发送给服务器。

服务器处理请求：服务器接收到请求后，根据请求的路径和方法处理请求，然后生成一个HTTP响应。

发送HTTP响应：服务器将响应数据发送回浏览器，如果是HTTPS，数据在发送前会被加密。

浏览器处理响应：浏览器接收到响应数据后，首先解析响应（对于HTTPS，先解密），然后根据响应的内容类型决定如何处理。如果是HTML文档，浏览器会解析HTML内容并构建DOM树。

加载资源：HTML文档中可能包含CSS、JavaScript、图片等资源的链接，浏览器会发起额外的请求来加载这些资源。

渲染页面：浏览器根据HTML构建的DOM树和加载的CSS样式信息构建渲染树，然后根据渲染树来布局和绘制页面。

执行JavaScript：如果页面包含JavaScript，浏览器会执行脚本，这可能会修改DOM树和渲染树，导致页面重新渲染。


## 浏览器reflow和repaint的区别

在浏览器中，reflow（重排）和repaint（重绘）是两种与渲染相关的操作，它们对性能有重要影响。

Repaint（重绘）
定义：当页面中元素的外观（颜色、边框样式等）发生变化，但没有影响到布局（如位置、大小等），浏览器会进行重绘操作，即重新绘制元素的这些外观变化。
触发条件：改变元素的视觉外观，但不影响布局的属性变化，如color、background-color、visibility等。
Reflow（重排）
定义：当元素的大小、位置、或内容发生变化，导致布局变化时，浏览器需要重新计算元素的位置和大小。这个过程称为重排。重排的成本比重绘高，因为它可能涉及到当前元素及其子元素、父元素和可能的同级元素的布局更新。
触发条件：添加或删除可见的DOM元素、元素位置改变、元素尺寸改变（例如，宽度、高度等的变化）、页面初次渲染、浏览器窗口尺寸改变等。
区别
性能影响：重排是一个更昂贵的操作，因为它涉及到布局的计算和更新。每次重排都会影响到更多的渲染流程环节。而重绘则仅仅涉及到视觉变化，不涉及到布局的变化，因此开销较小。
触发条件：重排通常由于布局或者几何属性的变化触发，而重绘则是由于视觉属性的变化触发。
优化建议
最小化重排和重绘：通过减少和优化DOM的操作，可以减少重排和重绘的次数。例如，使用cssText、className来集中更新样式，或者使用documentFragment来批量更新DOM。
批量读写DOM：读操作后立即进行写操作会导致浏览器强制布局，尽量避免布局抖动，可以通过分离读写操作来优化。
**使用will-change或transform**：对于动画效果，使用transform和opacity属性可以减少重排的影响，因为浏览器可以对这些变化进行优化处理。

## 浏览器不同标签页通信

**使用localStorage或sessionStorage**：

当一个标签页改变了localStorage或sessionStorage中的数据时，它会触发一个storage事件，其他标签页可以监听这个事件来获取更新。
限制：仅适用于同源标签页。
使用BroadcastChannel API：

BroadcastChannel API允许同源的不同标签页、iframe或者worker之间进行简单的通信。
创建一个BroadcastChannel对象，并通过它发送和接收消息。
限制：仅支持现代浏览器。
**使用Window.postMessage**：

通过postMessage方法可以安全地实现跨源通信。
需要获取其他标签页的window对象的引用，这通常通过用户在两个标签页之间进行某种形式的交互来实现（例如，通过window.open打开新标签页或iframe）。
**使用WebSockets或Server-Sent Events (SSE)**：

两个标签页可以独立地与服务器建立连接，服务器可以作为中介来转发消息。
这种方式不受同源策略的限制，但需要服务器端支持。
使用SharedWorker：

SharedWorker是一种特殊类型的Web Worker，它可以被多个脚本（即使是不同标签页、iframe或浏览器窗口）共享。
通过SharedWorker，不同的标签页可以共享同一个后台线程，并通过它进行通信。
限制：SharedWorker的支持并不是在所有浏览器中都很好。
